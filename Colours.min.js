"use strict";
var T = Object.defineProperty;
var M = (I, r) => T(I, "name", {value: r, configurable: !0});

class Colour {
	static {
		M(this, "Colour")
	}

	static hex2lab(r) {
		const [c, e, a] = Colour.hex2rgba(r);
		return Colour.rgba2lab(c, e, a, 1)
	}

	static rgba2lab(r, c, e, a) {
		const [t, n, h] = Colour.rgb2xyz(r, c, e);
		return Colour.xyz2lab(t, n, h)
	}

	static lab2rgba(r, c, e) {
		const [a, t, n] = Colour.lab2xyz(r, c, e);
		return [...Colour.xyz2rgba(a, t, n), 1]
	}

	static hex2rgba(r) {
		const c = r.replace(/^#/, "").toUpperCase();
		if (!/^[0-9A-F]+$/i.test(c) || ![3, 4, 6, 8].includes(c.length)) throw new Error(`Invalid HEX format: ${r}`);
		let a = c;
		[3, 4].includes(c.length) && (a = c.split("").map(o => o + o).join(""));
		const t = parseInt(a, 16);
		let n, h, s, i = 1;
		return a.length === 8 ? (i = (t & 255) / 255, n = t >> 16 & 255, h = t >> 8 & 255, s = t & 255) : (n = t >> 16 & 255, h = t >> 8 & 255, s = t & 255), [Math.min(255, Math.max(0, n)), Math.min(255, Math.max(0, h)), Math.min(255, Math.max(0, s)), Math.min(1, Math.max(0, i))]
	}

	static rgb2xyz(r, c, e) {
		const a = M(s => s > .04045 ? Math.pow((s + .055) / 1.055, 2.4) : s / 12.92, "linearize"), [t, n, h] = [r / 255, c / 255, e / 255].map(s => a(s) * 100);
		return [t * .4124564 + n * .3575761 + h * .1804375, t * .2126729 + n * .7151522 + h * .072175, t * .0193339 + n * .119192 + h * .9503041]
	}

	static xyz2rgba(r, c, e) {
		const a = M(i => (i = i > .0031308 ? 1.055 * Math.pow(i, .4166666666666667) - .055 : 12.92 * i, Math.round(Math.min(255, Math.max(0, i * 255)))), "normalize"),
			t = [r / 100, c / 100, e / 100], n = t[0] * 3.2404542 + t[1] * -1.5371385 + t[2] * -.4985314,
			h = t[0] * -.969266 + t[1] * 1.8760108 + t[2] * .041556,
			s = t[0] * .0556434 + t[1] * -.2040259 + t[2] * 1.0572252;
		return [a(n), a(h), a(s)]
	}

	static xyz2lab(r, c, e) {
		const a = M(s => s > .008856 ? Math.pow(s, .3333333333333333) : 7.787 * s + .13793103448275862, "f"),
			t = a(r / Colour.REF_X), n = a(c / Colour.REF_Y), h = a(e / Colour.REF_Z);
		return [116 * n - 16, 500 * (t - n), 200 * (n - h)]
	}

	static lab2xyz(r, c, e) {
		const a = (r + 16) / 116, t = c / 500 + a, n = a - e / 200,
			h = M(s => s > .2068966 ? Math.pow(s, 3) : (s - 16 / 116) / 7.787, "inverseF");
		return [h(t) * Colour.REF_X, h(a) * Colour.REF_Y, h(n) * Colour.REF_Z]
	}

	static deltaE00(r, c) {
		const [e, a, t] = r, [n, h, s] = c, i = M(y => y * 180 / Math.PI, "rad2deg"),
			o = M(y => y * Math.PI / 180, "deg2rad"), X = 1, f = 1, E = 1, j = Math.sqrt(a ** 2 + t ** 2),
			k = Math.sqrt(h ** 2 + s ** 2), R = (j + k) / 2, q = .5 * (1 - Math.sqrt(R ** 7 / (R ** 7 + 25 ** 7))),
			l = a * (1 + q), d = h * (1 + q), p = Math.sqrt(l ** 2 + t ** 2), g = Math.sqrt(d ** 2 + s ** 2),
			m = t === 0 && l === 0 ? 0 : i(Math.atan2(t, l)) % 360,
			z = s === 0 && d === 0 ? 0 : i(Math.atan2(s, d)) % 360, S = n - e, v = g - p;
		let b = 0;
		p * g !== 0 && (b = z - m, b > 180 ? b -= 360 : b < -180 && (b += 360));
		const L = 2 * Math.sqrt(p * g) * Math.sin(o(b) / 2), w = (e + n) / 2, F = (p + g) / 2;
		let x = (m + z) / 2;
		Math.abs(m - z) > 180 && (x += 180);
		const Y = 1 - .17 * Math.cos(o(x - 30)) + .24 * Math.cos(o(2 * x)) + .32 * Math.cos(o(3 * x + 6)) - .2 * Math.cos(o(4 * x - 63)),
			Z = 1 + .015 * (w - 50) ** 2 / Math.sqrt(20 + (w - 50) ** 2), u = 1 + .045 * F, H = 1 + .015 * F * Y,
			A = 30 * Math.exp((-((x - 275) / 25)) ** 2),
			P = -(2 * Math.sqrt(F ** 7 / (F ** 7 + 25 ** 7))) * Math.sin(o(2 * A));
		return Math.sqrt((S / (X * Z)) ** 2 + (v / (f * u)) ** 2 + (L / (E * H)) ** 2 + P * (v / (f * u)) * (L / (E * H)))
	}

	static adjustLightness(r, c, e, a, t) {
		const [n, h, s] = Colour.rgba2lab(r, c, e, a), i = Math.min(100, Math.max(0, n + n * t));
		return [...Colour.lab2rgba(i, h, s)]
	}
}

Colour.REF_X = 95.047, Colour.REF_Y = 100, Colour.REF_Z = 108.883;
//# sourceMappingURL=Colours.min.js.map
